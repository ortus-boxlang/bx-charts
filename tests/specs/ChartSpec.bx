
/**
 * BoxLang Charts Integration Tests
 */
class extends="testbox.system.BaseSpec"{

	/*********************************** LIFE CYCLE Methods ***********************************/

	/**
	 * executes before all suites+specs in the run() method
	 */
	function beforeAll(){
		// Setup test data
		variables.testData = {
			"jvmFreeMemory": 512,
			"jvmMaxMemory": 1024,
			"jvmTotalMemory": 768,
			"cacheHits": 150,
			"cacheMisses": 25,
			"cacheEvictions": 5,
			"cacheGarbageCollections": 2
		};
	}

	/**
	 * executes after all suites+specs in the run() method
	 */
	function afterAll(){

	}

	/*********************************** BDD SUITES ***********************************/

	function run( testResults, testBox ){
		describe( "BoxLang Charts Enhanced Features", () => {

			it( "can render a pie chart with axis titles and custom colors", () => {
				// This would typically use BoxLang's component rendering system
				// For now, we'll test the component structure and attributes

				var chartAttributes = {
					"title": "JVM Memory Usage",
					"chartwidth": 400,
					"chartheight": 300,
					"backgroundcolor": "#ffffff",
					"xaxistitle": "Memory Type",
					"yaxistitle": "Memory (KB)",
					"showxgridlines": true,
					"showygridlines": false
				};

				var seriesAttributes = {
					"type": "pie",
					"colorlist": "00ff00, 0000ff, gray",
					"serieslabel": "JVM Memory Distribution"
				};

				var chartDataItems = [
					{ "item": "Free Memory (KB)", "value": variables.testData.jvmFreeMemory },
					{ "item": "Used Memory (KB)", "value": variables.testData.jvmMaxMemory - variables.testData.jvmFreeMemory },
					{ "item": "Unallocated Memory (KB)", "value": variables.testData.jvmMaxMemory - variables.testData.jvmTotalMemory }
				];

				// Test chart component attributes
				expect( chartAttributes.xaxistitle ).toBe( "Memory Type" );
				expect( chartAttributes.yaxistitle ).toBe( "Memory (KB)" );
				expect( seriesAttributes.serieslabel ).toBe( "JVM Memory Distribution" );
				expect( arrayLen( chartDataItems ) ).toBe( 3 );
			} );

			it( "supports all new chart types", () => {
				var validChartTypes = [ "pie", "bar", "line", "doughnut", "radar", "polarArea", "area", "horizontalbar", "scatter", "bubble" ];

				// Test that all chart types are supported
				expect( arrayContains( validChartTypes, "area" ) ).toBeTrue( "Area charts should be supported" );
				expect( arrayContains( validChartTypes, "horizontalbar" ) ).toBeTrue( "Horizontal bar charts should be supported" );
				expect( arrayContains( validChartTypes, "scatter" ) ).toBeTrue( "Scatter plots should be supported" );
				expect( arrayContains( validChartTypes, "bubble" ) ).toBeTrue( "Bubble charts should be supported" );

				// Test original types still work
				expect( arrayContains( validChartTypes, "pie" ) ).toBeTrue( "Pie charts should still be supported" );
				expect( arrayContains( validChartTypes, "bar" ) ).toBeTrue( "Bar charts should still be supported" );
				expect( arrayContains( validChartTypes, "line" ) ).toBeTrue( "Line charts should still be supported" );
			} );

			it( "handles series placement configuration", () => {
				var seriesPlacementOptions = [ "default", "cluster", "stacked" ];

				// Test all placement options
				for ( var placement in seriesPlacementOptions ) {
					var chartConfig = {
						"seriesplacement": placement,
						"type": "bar"
					};

					// Verify placement option is valid
					expect( arrayContains( seriesPlacementOptions, placement ) ).toBeTrue( "Series placement '#placement#' should be valid" );
				}
			} );

			it( "processes color lists correctly", () => {
				var colorTests = [
					{ "input": "ff0000, 00ff00, 0000ff", "description": "Hex colors without # prefix" },
					{ "input": "#ff0000, #00ff00, #0000ff", "description": "Hex colors with # prefix" },
					{ "input": "##ff0000, ##00ff00, ##0000ff", "description": "Hex colors with ## prefix (BoxLang)" },
					{ "input": "red, green, blue", "description": "Named colors" }
				];

				for ( var colorTest in colorTests ) {
					var colorList = listToArray( colorTest.input );
					expect( arrayLen( colorList ) ).toBe( 3, "Color list should have 3 colors for: #colorTest.description#" );
				}
			} );

			it( "validates grid line configuration", () => {
				var gridLineConfig = {
					"showxgridlines": true,
					"showygridlines": false
				};

				// Test boolean grid line settings
				expect( isBoolean( gridLineConfig.showxgridlines ) ).toBeTrue( "X grid lines should be boolean" );
				expect( isBoolean( gridLineConfig.showygridlines ) ).toBeTrue( "Y grid lines should be boolean" );
				expect( gridLineConfig.showxgridlines ).toBeTrue( "X grid lines should be enabled" );
				expect( gridLineConfig.showygridlines ).toBeFalse( "Y grid lines should be disabled" );
			} );

			it( "supports comprehensive chart data structures", () => {
				var sampleChartData = [
					{ "item": "Q1 Sales", "value": 100000 },
					{ "item": "Q2 Sales", "value": 125000 },
					{ "item": "Q3 Sales", "value": 150000 },
					{ "item": "Q4 Sales", "value": 175000 }
				];

				// Test data structure
				for ( var dataPoint in sampleChartData ) {
					expect( structKeyExists( dataPoint, "item" ) ).toBeTrue( "Data point should have 'item' key" );
					expect( structKeyExists( dataPoint, "value" ) ).toBeTrue( "Data point should have 'value' key" );
					expect( len( dataPoint.item ) ).toBeGT( 0, "Item should not be empty" );
					expect( isNumeric( dataPoint.value ) ).toBeTrue( "Value should be numeric" );
				}
			} );

			it( "handles chart dimension configuration", () => {
				var dimensionTests = [
					{ "width": 400, "height": 300, "description": "Standard dimensions" },
					{ "width": 800, "height": 600, "description": "Large dimensions" },
					{ "width": 250, "height": 200, "description": "Small dimensions" }
				];

				for ( var test in dimensionTests ) {
					expect( test.width ).toBeGT( 0, "Width should be positive for: #test.description#" );
					expect( test.height ).toBeGT( 0, "Height should be positive for: #test.description#" );
					expect( isNumeric( test.width ) ).toBeTrue( "Width should be numeric for: #test.description#" );
					expect( isNumeric( test.height ) ).toBeTrue( "Height should be numeric for: #test.description#" );
				}
			} );

			it( "supports complex chart configurations", () => {
				var complexChartConfig = {
					"title": "Complex Performance Dashboard",
					"chartwidth": 600,
					"chartheight": 400,
					"backgroundcolor": "#f8f9fa",
					"showlegend": true,
					"show3d": false,
					"xaxistitle": "Time Period",
					"yaxistitle": "Performance Metrics",
					"showxgridlines": true,
					"showygridlines": true,
					"seriesplacement": "stacked"
				};

				// Validate complex configuration
				expect( len( complexChartConfig.title ) ).toBeGT( 0, "Title should not be empty" );
				expect( complexChartConfig.chartwidth ).toBeGT( 0, "Chart width should be positive" );
				expect( complexChartConfig.chartheight ).toBeGT( 0, "Chart height should be positive" );
				expect( isBoolean( complexChartConfig.showlegend ) ).toBeTrue( "Show legend should be boolean" );
				expect( len( complexChartConfig.xaxistitle ) ).toBeGT( 0, "X-axis title should not be empty" );
				expect( len( complexChartConfig.yaxistitle ) ).toBeGT( 0, "Y-axis title should not be empty" );
			} );

			it( "supports responsive chart configuration", () => {
				var responsiveConfig = {
					"responsive": true,
					"maintainAspectRatio": true,
					"aspectRatio": 2
				};

				// Test responsive configuration
				expect( isBoolean( responsiveConfig.responsive ) ).toBeTrue( "Responsive should be boolean" );
				expect( isBoolean( responsiveConfig.maintainAspectRatio ) ).toBeTrue( "MaintainAspectRatio should be boolean" );
				expect( isNumeric( responsiveConfig.aspectRatio ) ).toBeTrue( "AspectRatio should be numeric" );
				expect( responsiveConfig.aspectRatio ).toBeGT( 0, "AspectRatio should be positive" );
			} );

			it( "validates aspect ratio values", () => {
				var aspectRatioTests = [
					{ "ratio": 1, "description": "Square (1:1)" },
					{ "ratio": 2, "description": "Wide (2:1)" },
					{ "ratio": 3, "description": "Very wide (3:1)" },
					{ "ratio": 0.5, "description": "Tall (1:2)" }
				];

				for ( var test in aspectRatioTests ) {
					expect( test.ratio ).toBeGT( 0, "Aspect ratio should be positive for: #test.description#" );
					expect( isNumeric( test.ratio ) ).toBeTrue( "Aspect ratio should be numeric for: #test.description#" );
				}
			} );

			it( "handles responsive chart attributes correctly", () => {
				var chartAttributes = {
					"responsive": true,
					"maintainAspectRatio": false,
					"aspectRatio": 1.5,
					"chartwidth": 800,
					"chartheight": 400
				};

				// Validate attributes
				expect( chartAttributes.responsive ).toBeTrue( "Responsive should be enabled" );
				expect( chartAttributes.maintainAspectRatio ).toBeFalse( "MaintainAspectRatio should be disabled" );
				expect( chartAttributes.aspectRatio ).toBe( 1.5, "AspectRatio should be 1.5" );
				expect( chartAttributes.chartwidth ).toBe( 800, "Chart width should be 800" );
				expect( chartAttributes.chartheight ).toBe( 400, "Chart height should be 400" );
			} );

			it( "supports bubble chart data structure", () => {
				var bubbleChartData = [
					{ "item": "Data Point 1", "x": 10, "y": 20, "r": 5 },
					{ "item": "Data Point 2", "x": 15, "y": 25, "r": 8 },
					{ "item": "Data Point 3", "x": 20, "y": 30, "r": 12 }
				];

				// Test bubble data structure
				for ( var dataPoint in bubbleChartData ) {
					expect( structKeyExists( dataPoint, "item" ) ).toBeTrue( "Data point should have 'item' key" );
					expect( structKeyExists( dataPoint, "x" ) ).toBeTrue( "Data point should have 'x' key" );
					expect( structKeyExists( dataPoint, "y" ) ).toBeTrue( "Data point should have 'y' key" );
					expect( structKeyExists( dataPoint, "r" ) ).toBeTrue( "Data point should have 'r' key (radius)" );
					expect( isNumeric( dataPoint.x ) ).toBeTrue( "X coordinate should be numeric" );
					expect( isNumeric( dataPoint.y ) ).toBeTrue( "Y coordinate should be numeric" );
					expect( isNumeric( dataPoint.r ) ).toBeTrue( "Radius should be numeric" );
				}
			} );

			it( "supports resizeDelay attribute for performance optimization", () => {
				var chartAttributes = {
					"responsive": true,
					"resizeDelay": 100
				};

				// Validate resize delay
				expect( isNumeric( chartAttributes.resizeDelay ) ).toBeTrue( "ResizeDelay should be numeric" );
				expect( chartAttributes.resizeDelay ).toBeGTE( 0, "ResizeDelay should be non-negative" );
				expect( chartAttributes.resizeDelay ).toBe( 100, "ResizeDelay should be 100ms" );
			} );

			it( "can use query as data source with default column names", () => {
				// Create test query
				var testQuery = queryNew(
					"item,value",
					"varchar,integer",
					[
						{ "item": "Product A", "value": 100 },
						{ "item": "Product B", "value": 200 },
						{ "item": "Product C", "value": 150 }
					]
				);

				// Validate query structure
				expect( testQuery.recordCount ).toBe( 3, "Query should have 3 records" );
				expect( listFindNoCase( testQuery.columnList, "item" ) ).toBeGT( 0, "Query should have 'item' column" );
				expect( listFindNoCase( testQuery.columnList, "value" ) ).toBeGT( 0, "Query should have 'value' column" );
			} );

			it( "can use query with custom column names", () => {
				// Create test query with custom columns
				var testQuery = queryNew(
					"category,amount",
					"varchar,integer",
					[
						{ "category": "Sales", "amount": 5000 },
						{ "category": "Marketing", "amount": 3000 },
						{ "category": "Operations", "amount": 4000 }
					]
				);

				// Validate query structure
				expect( testQuery.recordCount ).toBe( 3, "Query should have 3 records" );
				expect( listFindNoCase( testQuery.columnList, "category" ) ).toBeGT( 0, "Query should have 'category' column" );
				expect( listFindNoCase( testQuery.columnList, "amount" ) ).toBeGT( 0, "Query should have 'amount' column" );
			} );

			it( "validates query has records", () => {
				// Create empty query
				var emptyQuery = queryNew( "item,value", "varchar,integer" );

				// Validate empty query
				expect( emptyQuery.recordCount ).toBe( 0, "Empty query should have 0 records" );
			} );

			it( "validates query column existence", () => {
				// Create test query
				var testQuery = queryNew(
					"name,count",
					"varchar,integer",
					[
						{ "name": "Test", "count": 10 }
					]
				);

				var queryColumns = listToArray( testQuery.columnList );

				// Validate columns
				expect( arrayContainsNoCase( queryColumns, "name" ) ).toBeTrue( "Query should have 'name' column" );
				expect( arrayContainsNoCase( queryColumns, "count" ) ).toBeTrue( "Query should have 'count' column" );
				expect( arrayContainsNoCase( queryColumns, "invalid" ) ).toBeFalse( "Query should not have 'invalid' column" );
			} );

			it( "can use array of structs as data source", () => {
				// Create test data array with structs
				var testData = [
					{ "item": "Product A", "value": 100 },
					{ "item": "Product B", "value": 200 },
					{ "item": "Product C", "value": 150 }
				];

				// Validate array structure
				expect( arrayLen( testData ) ).toBe( 3, "Array should have 3 elements" );
				for ( var dataPoint in testData ) {
					expect( structKeyExists( dataPoint, "item" ) ).toBeTrue( "Data point should have 'item' key" );
					expect( structKeyExists( dataPoint, "value" ) ).toBeTrue( "Data point should have 'value' key" );
				}
			} );

			it( "can use array of arrays as data source", () => {
				// Create test data array with arrays
				var testData = [
					[ "Product A", 100 ],
					[ "Product B", 200 ],
					[ "Product C", 150 ]
				];

				// Validate array structure
				expect( arrayLen( testData ) ).toBe( 3, "Array should have 3 elements" );
				for ( var dataPoint in testData ) {
					expect( isArray( dataPoint ) ).toBeTrue( "Data point should be an array" );
					expect( arrayLen( dataPoint ) ).toBe( 2, "Data point should have 2 elements [item, value]" );
				}
			} );

			it( "can use array of structs for bubble chart data", () => {
				// Create test data array for bubble charts
				var testData = [
					{ "item": "Point A", "x": 10, "y": 20, "r": 5 },
					{ "item": "Point B", "x": 15, "y": 25, "r": 8 },
					{ "item": "Point C", "x": 20, "y": 30, "r": 12 }
				];

				// Validate bubble array structure
				expect( arrayLen( testData ) ).toBe( 3, "Array should have 3 elements" );
				for ( var dataPoint in testData ) {
					expect( structKeyExists( dataPoint, "item" ) ).toBeTrue( "Data point should have 'item' key" );
					expect( structKeyExists( dataPoint, "x" ) ).toBeTrue( "Data point should have 'x' key" );
					expect( structKeyExists( dataPoint, "y" ) ).toBeTrue( "Data point should have 'y' key" );
					expect( structKeyExists( dataPoint, "r" ) ).toBeTrue( "Data point should have 'r' key" );
				}
			} );

			it( "can use array of arrays for bubble chart data", () => {
				// Create test data array for bubble charts with positional format
				var testData = [
					[ "Point A", 10, 20, 5 ],
					[ "Point B", 15, 25, 8 ],
					[ "Point C", 20, 30, 12 ]
				];

				// Validate bubble array structure
				expect( arrayLen( testData ) ).toBe( 3, "Array should have 3 elements" );
				for ( var dataPoint in testData ) {
					expect( isArray( dataPoint ) ).toBeTrue( "Data point should be an array" );
					expect( arrayLen( dataPoint ) ).toBe( 4, "Data point should have 4 elements [item, x, y, r]" );
				}
			} );

			it( "validates array data is not empty", () => {
				// Create empty array
				var emptyArray = [];

				// Validate empty array
				expect( arrayLen( emptyArray ) ).toBe( 0, "Empty array should have 0 elements" );
			} );

			it( "validates mixed formats are not allowed", () => {
				// This would be an invalid array with mixed types
				var mixedArray = [
					{ "item": "Product A", "value": 100 },
					[ "Product B", 200 ]
				];

				// First element is struct, second is array - this should fail validation
				expect( isStruct( mixedArray[1] ) ).toBeTrue( "First element should be struct" );
				expect( isArray( mixedArray[2] ) ).toBeTrue( "Second element should be array" );
			} );

			it( "supports borderColor attribute", () => {
				var borderColorTests = [
					{ "input": "##FF0000", "description": "Hex color with ## prefix" },
					{ "input": "#FF0000", "description": "Hex color with # prefix" },
					{ "input": "red", "description": "Named color" },
					{ "input": "", "description": "Empty string (no border)" }
				];

				for ( var test in borderColorTests ) {
					// Test that borderColor can be set to various formats
					expect( isString( test.input ) ).toBeTrue( "borderColor should accept string values for: #test.description#" );
				}
			} );

			it( "supports borderWidth attribute with chart type defaults", () => {
				var borderWidthDefaults = {
					"bar": 1,
					"horizontalbar": 1,
					"line": 3,
					"area": 3,
					"radar": 3,
					"pie": 2,
					"doughnut": 2,
					"polarArea": 2,
					"bubble": 2
				};

				// Test default values
				for ( var chartType in borderWidthDefaults ) {
					var defaultWidth = borderWidthDefaults[ chartType ];
					expect( isNumeric( defaultWidth ) ).toBeTrue( "borderWidth default for #chartType# should be numeric" );
					expect( defaultWidth ).toBeGT( 0, "borderWidth default for #chartType# should be positive" );
				}

				// Test custom borderWidth
				var customWidth = 5;
				expect( isNumeric( customWidth ) ).toBeTrue( "Custom borderWidth should be numeric" );
				expect( customWidth ).toBeGT( 0, "Custom borderWidth should be positive" );
			} );

			it( "supports borderRadius attribute for bar charts only", () => {
				var supportedTypes = [ "bar", "horizontalbar" ];
				var unsupportedTypes = [ "line", "area", "pie", "doughnut", "radar", "polarArea", "scatter", "bubble" ];

				// Test borderRadius is numeric
				var borderRadius = 10;
				expect( isNumeric( borderRadius ) ).toBeTrue( "borderRadius should be numeric" );
				expect( borderRadius ).toBeGTE( 0, "borderRadius should be non-negative" );

				// Validate supported types
				for ( var type in supportedTypes ) {
					expect( listFindNoCase( "bar,horizontalbar", type ) ).toBeGT( 0, "#type# should support borderRadius" );
				}

				// Validate unsupported types
				for ( var type in unsupportedTypes ) {
					expect( listFindNoCase( "bar,horizontalbar", type ) ).toBe( 0, "#type# should not support borderRadius" );
				}
			} );


		} );

		describe( "Series-Level Border Attributes", () => {

			it( "supports series-level borderColor that overrides chart-level", () => {
				// Test series-level borderColor validation
				var seriesBorderColors = [ "##FF0000", "red", "##2c3e50", "blue" ];

				for ( var color in seriesBorderColors ) {
					expect( len( trim( color ) ) ).toBeGT( 0, "Series borderColor '#color#' should not be empty" );
					// Validate hex format (starts with ## and 6 chars) or named color
					if ( left( color, 2 ) == "##" ) {
						expect( len( color ) ).toBe( 8, "Hex color '#color#' should be 8 characters (## + 6 digits)" );
					}
				}

				// Test chart types that support borderColor
				var supportedTypes = [ "bar", "line", "area", "pie", "doughnut", "radar", "polarArea", "bubble", "horizontalbar" ];
				for ( var type in supportedTypes ) {
					expect( listFindNoCase( "bar,line,area,pie,doughnut,radar,polarArea,bubble,horizontalbar", type ) ).toBeGT( 0, "#type# should support series-level borderColor" );
				}

				// scatter does NOT support borderColor
				expect( listFindNoCase( "bar,line,area,pie,doughnut,radar,polarArea,bubble,horizontalbar", "scatter" ) ).toBe( 0, "scatter should not support borderColor" );
			} );

			it( "supports series-level borderWidth that overrides chart-level", () => {
				// Test series-level borderWidth validation
				var seriesWidths = [ 1, 2, 3, 5, 10 ];

				for ( var width in seriesWidths ) {
					expect( isNumeric( width ) ).toBeTrue( "Series borderWidth should be numeric" );
					expect( width ).toBeGT( 0, "Series borderWidth should be positive" );
				}

				// Test chart types that support borderWidth
				var supportedTypes = [ "bar", "line", "area", "pie", "doughnut", "radar", "polarArea", "bubble", "horizontalbar" ];
				for ( var type in supportedTypes ) {
					expect( listFindNoCase( "bar,line,area,pie,doughnut,radar,polarArea,bubble,horizontalbar", type ) ).toBeGT( 0, "#type# should support series-level borderWidth" );
				}

				// scatter does NOT support borderWidth
				expect( listFindNoCase( "bar,line,area,pie,doughnut,radar,polarArea,bubble,horizontalbar", "scatter" ) ).toBe( 0, "scatter should not support borderWidth" );
			} );

			it( "supports series-level borderRadius that overrides chart-level for bar charts only", () => {
				// Test series-level borderRadius validation
				var seriesRadii = [ 0, 4, 6, 8, 10, 15 ];

				for ( var radius in seriesRadii ) {
					expect( isNumeric( radius ) ).toBeTrue( "Series borderRadius should be numeric" );
					expect( radius ).toBeGTE( 0, "Series borderRadius should be non-negative" );
				}

				// Test chart types that support borderRadius (bar and horizontalbar only)
				var supportedTypes = [ "bar", "horizontalbar" ];
				var unsupportedTypes = [ "line", "area", "pie", "doughnut", "radar", "polarArea", "scatter", "bubble" ];

				for ( var type in supportedTypes ) {
					expect( listFindNoCase( "bar,horizontalbar", type ) ).toBeGT( 0, "#type# should support series-level borderRadius" );
				}

				for ( var type in unsupportedTypes ) {
					expect( listFindNoCase( "bar,horizontalbar", type ) ).toBe( 0, "#type# should not support series-level borderRadius" );
				}
			} );

		} );
	}

}
```}