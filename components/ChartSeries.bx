/**
 * BoxLang ChartSeries Component - Defines a data series for charts
 * <p>
 * This component must be nested within a chart component.
 * It defines the chart type and styling, and contains chartData components.
 * <p>
 * Usage:
 * <pre>
 * <bx:chartseries type="pie" colorlist="red,blue,green">
 *   <bx:chartdata item="Item 1" value="100">
 *   <bx:chartdata item="Item 2" value="200">
 * </bx:chartseries>
 * </pre>
 */
@BoxComponent( "chartseries" )
@AllowsBody( true )
@RequiresBody( true )
class{

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * --------------------------------------------------------------------------
	 * Static Chart Type Mappings
	 * --------------------------------------------------------------------------
	 */
	static chartTypeMap = {
		"pie": "pie",
		"bar": "bar",
		"line": "line",
		"doughnut": "doughnut",
		"radar": "radar",
		"polararea": "polarArea",
		"area": "line",
		"horizontalbar": "bar",
		"scatter": "scatter",
		"bubble": "bubble"
	};

	/**
	 * Defines a chart series with type and styling
	 *
	 * @param context The context of the execution (IBoxContext)
	 * @param attributes The attributes of the component that were passed in
	 * @param body The body of the component containing chartdata components
	 * @param executionState The execution state of the component
	 *
	 * @return A BodyResult instance or null for a default result return.
	 */
	function invoke( required context, Struct attributes, any body, Struct executionState ){
		// This component must be nested within a chart component
		var parentState = context.findClosestComponent( "chart" );
		if ( isNull( parentState ) ) {
			throw( type="BXChartException", message: "chartseries must be nested within a chart component" );
		}

		// Validate required attributes
		if ( !structKeyExists( attributes, "type" ) || !len( trim( attributes.type ) ) ) {
			throw( type="BXChartException", message: "chartseries requires a 'type' attribute (pie, bar, line, etc.)" );
		}

		// Validate chart type
		var validTypes = [ "pie", "bar", "line", "doughnut", "radar", "polararea", "area", "horizontalbar", "scatter", "bubble" ];
		var chartType = lcase( trim( attributes.type ) );
		if ( !arrayContains( validTypes, chartType ) ) {
			throw ( type: "BXChartException", message: "Invalid chart type '#chartType#'. Valid types are: #arrayToList( validTypes )#" );
		}
		chartType = static.chartTypeMap[ chartType ];

		// Initialize this series data structure
		executionState.type = chartType;
		executionState.colorlist = attributes.colorlist ?: "";
		executionState.serieslabel = attributes.serieslabel ?: chartType;
		executionState.chartData = [];

		// Process the body to collect chartdata components
		var buffer = newBuffer();
		var bodyResult = processBody( context, body, buffer );

		// If there was a return statement inside our body, we early exit now
		if ( bodyResult.isEarlyExit() ) {
			return bodyResult;
		}

		// Create the series data structure
		var seriesData = {
			"type": chartType,
			"colorlist": executionState.colorlist,
			"serieslabel": executionState.serieslabel,
			"chartData": executionState.chartData
		};

		// Add this series to the parent chart
		arrayAppend( parentState.chartSeries, seriesData );

		return null; // Default return
	}

}