/**
 * BoxLang ChartSeries Component - Defines a data series for charts
 * <p>
 * This component must be nested within a chart component.
 * It defines the chart type and styling, and contains chartData components or uses a query data source.
 * <p>
 * Usage with chartData components:
 * <pre>
 * <bx:chartseries type="pie" colorlist="red,blue,green">
 *   <bx:chartdata item="Item 1" value="100">
 *   <bx:chartdata item="Item 2" value="200">
 * </bx:chartseries>
 * </pre>
 * <p>
 * Usage with query:
 * <pre>
 * <bx:chartseries type="bar" query="#myQuery#" itemColumn="category" valueColumn="amount">
 * </bx:chartseries>
 * </pre>
 * <p>
 * <h2>Attributes</h2>
 * <ul>
 *   <li><b>type</b> (string, required) - Chart type: pie, bar, line, doughnut, radar, polarArea, area, horizontalbar, scatter, bubble</li>
 *   <li><b>colorlist</b> (string, optional) - Comma-separated list of colors (hex or named colors) for chart data points</li>
 *   <li><b>serieslabel</b> (string, optional) - Label for this data series, defaults to chart type</li>
 *   <li><b>query</b> (query, optional) - Query object to use as data source. When provided, no child chartData components are required</li>
 *   <li><b>itemColumn</b> (string, optional) - Name of the query column containing labels. Default: "item"</li>
 *   <li><b>valueColumn</b> (string, optional) - Name of the query column containing values. Default: "value"</li>
 * </ul>
 */
@BoxComponent( "chartseries" )
@AllowsBody( true )
@RequiresBody( false )
class{

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * --------------------------------------------------------------------------
	 * Static Chart Type Mappings
	 * --------------------------------------------------------------------------
	 */
	static chartTypeMap = {
		"pie": "pie",
		"bar": "bar",
		"line": "line",
		"doughnut": "doughnut",
		"radar": "radar",
		"polararea": "polarArea",
		"area": "line",
		"horizontalbar": "bar",
		"scatter": "scatter",
		"bubble": "bubble"
	};

	/**
	 * Defines a chart series with type and styling
	 *
	 * @param context The context of the execution (IBoxContext)
	 * @param attributes The attributes of the component that were passed in
	 * @param body The body of the component containing chartdata components
	 * @param executionState The execution state of the component
	 *
	 * @return A BodyResult instance or null for a default result return.
	 */
	function invoke( required context, Struct attributes, any body, Struct executionState ){
		// This component must be nested within a chart component
		var parentState = context.findClosestComponent( "chart" );
		if ( isNull( parentState ) ) {
			throw( type="BXChartException", message: "chartseries must be nested within a chart component" );
		}

		// Validate required attributes
		if ( !structKeyExists( attributes, "type" ) || !len( trim( attributes.type ) ) ) {
			throw( type="BXChartException", message: "chartseries requires a 'type' attribute (pie, bar, line, etc.)" );
		}

		// Validate chart type
		var validTypes = [ "pie", "bar", "line", "doughnut", "radar", "polararea", "area", "horizontalbar", "scatter", "bubble" ];
		var chartType = lcase( trim( attributes.type ) );
		if ( !arrayContains( validTypes, chartType ) ) {
			throw ( type: "BXChartException", message: "Invalid chart type '#chartType#'. Valid types are: #arrayToList( validTypes )#" );
		}
		chartType = static.chartTypeMap[ chartType ];

		// Initialize this series data structure
		executionState.type = chartType;
		executionState.colorlist = attributes.colorlist ?: "";
		executionState.serieslabel = attributes.serieslabel ?: chartType;
		executionState.chartData = [];

		// Check if using query data source
		var hasQuery = structKeyExists( attributes, "query" ) && !isNull( attributes.query );
		
		if ( hasQuery ) {
			// Use query as data source
			var itemColumn = attributes.itemColumn ?: "item";
			var valueColumn = attributes.valueColumn ?: "value";
			
			// Convert query to chart data array
			executionState.chartData = convertQueryToChartData( 
				attributes.query, 
				itemColumn, 
				valueColumn 
			);
		} else {
			// Process the body to collect chartdata components
			var buffer = newBuffer();
			var bodyResult = processBody( context, body, buffer );

			// If there was a return statement inside our body, we early exit now
			if ( bodyResult.isEarlyExit() ) {
				return bodyResult;
			}
		}

		// Create the series data structure
		var seriesData = {
			"type": chartType,
			"colorlist": executionState.colorlist,
			"serieslabel": executionState.serieslabel,
			"chartData": executionState.chartData
		};

		// Add this series to the parent chart
		arrayAppend( parentState.chartSeries, seriesData );

		return null; // Default return
	}

	/**
	 * Converts a query to an array of chart data objects
	 *
	 * @param query The query object to convert
	 * @param itemColumn The name of the column containing item labels
	 * @param valueColumn The name of the column containing values
	 *
	 * @return Array of chart data objects with item and value properties
	 */
	private function convertQueryToChartData( required query, required itemColumn, required valueColumn ){
		// Validate that the query has records
		if ( query.recordCount == 0 ) {
			throw( 
				type: "BXChartException", 
				message: "Query data source must contain at least one record. The provided query is empty." 
			);
		}

		// Get query column names for validation
		var queryColumns = listToArray( query.columnList );
		
		// Validate itemColumn exists
		if ( !arrayContainsNoCase( queryColumns, itemColumn ) ) {
			throw( 
				type: "BXChartException", 
				message: "The itemColumn '#itemColumn#' does not exist in the query. Available columns: #query.columnList#" 
			);
		}
		
		// Validate valueColumn exists
		if ( !arrayContainsNoCase( queryColumns, valueColumn ) ) {
			throw( 
				type: "BXChartException", 
				message: "The valueColumn '#valueColumn#' does not exist in the query. Available columns: #query.columnList#" 
			);
		}

		// Convert query to array of data objects
		var chartData = [];
		
		for ( var row = 1; row <= query.recordCount; row++ ) {
			var dataPoint = {
				"item": trim( query[ itemColumn ][ row ] ),
				"value": query[ valueColumn ][ row ]
			};
			arrayAppend( chartData, dataPoint );
		}

		return chartData;
	}

}