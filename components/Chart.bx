/**
 * BoxLang Chart Component - Renders charts using Chart.js
 * <p>
 * This component creates interactive charts using the Chart.js library.
 * It processes chartSeries and chartData child components to build the chart configuration.
 * <p>
 * Basic Usage:
 * <pre>
 * <bx:chart title="My Chart" chartwidth="400" chartheight="300">
 *   <bx:chartseries type="pie">
 *     <bx:chartdata item="Item 1" value="100">
 *     <bx:chartdata item="Item 2" value="200">
 *   </bx:chartseries>
 * </bx:chart>
 * </pre>
 */
@BoxComponent( "chart" )
@AllowsBody( true )
@RequiresBody( true )
class{

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * Renders a chart using Chart.js
	 *
	 * @param context The context of the execution (IBoxContext)
	 * @param attributes The attributes of the component that were passed in
	 * @param body The body of the component containing chartseries and chartdata
	 * @param executionState The execution state of the component
	 *
	 * Supported attributes
	 *
	 * @attribute.backgroundColor - string, optional -  Color of the area between the data background and the chart border, around labels and around the legend. Hexadecimal value or supported named color. For a hex value, use the form: textColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none.
	 * @attribute.chartHeight - number, optional -  Chart height; integer number of pixels
	 * @attribute.chartWidth - number, optional -  Chart width; integer number of pixels
	 * @attribute.font - string, optional -  Font of data in column..
	 * @attribute.show3D - boolean, optional -  Display chart with three-dimensional appearance.
	 * @attribute.showLegend - boolean, optional -  yes: if chart contains more than one data series, display legend
	 * @attribute.showXGridlines - boolean, optional -  yes: display X-axis gridlines
	 * @attribute.source - string, optional -  variable name of the source path, if set the path to the source file is returned and no image tag is written to response stream.
	 * @attribute.showYGridlines - boolean, optional -  yes: display Y-axis gridlines.
	 * @attribute.title - string, optional -  Title of the chart.
	 * @attribute.xAxisTitle - string, optional -  text; X-axis title
	 * @attribute.yAxisTitle - string, optional -  text; Y-axis title
	 *
	 * Newly implemented attributes
	 * @attribute.dataBackgroundColor - string, optional -  color for control. For a hex value, use the form: textColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none.
	 * @attribute.fontBold - boolean, optional -  Yes: displays grid control text in bold.
	 * @attribute.fontItalic - boolean, optional -  Yes: displays grid control text in italics.
	 * @attribute.fontSize - number, optional -  Size of text in column. Default: 12.
	 * @attribute.foregroundColor - string, optional -  color for control. For a hex value, use the form: textColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none. Default: ##333333.
	 * @attribute.labelFormat - string, optional -  Format for Y-axis labels. Use {value} placeholder for the actual value.
	 * @attribute.categoryLabelPositions - string, optional -  Label position relative to axis: standard, up_45, up_90, down_45, down_90 or horizontal (standard) and vertical (down_90). Default is horizontal.
	 * @attribute.markerSize - number, optional -  Size of data point marker in pixels. Integer. Default: 4.
	 * @attribute.scaleFrom - number, optional -  Y-axis minimum value; integer.
	 * @attribute.scaleTo - number, optional -  Y-axis max value; integer.
	 * @attribute.showBorder - boolean, optional -  Whether to display a border around the chart.
	 * @attribute.showMarkers - boolean, optional -  Applies to chartseries type attribute values line, curve and scatter. yes: display markers at data points. Default: true.
	 * @attribute.showXLabel - boolean, optional -  yes: shows the x-axis labels. Default: true.
	 * @attribute.showTooltip - boolean, optional -  show the tooltip or not. Default: true.
	 * @attribute.sortXAxis - boolean, optional -  Display column labels in alphabetic order along X-axis. Ignored if the xAxisType attribute is scale.
	 * @attribute.url - string, optional -  URL to open if the user clicks item in a data series.
	 *
	 * Unimplemented attributes (not feasible with Chart.js or not essential)
	 * @attribute.format - string, optional -  File format in which to save graph. Not implemented (web charts only support canvas/HTML)
	 * @attribute.name - string, optional -  Page variable name. Not implemented (not applicable to web charts)
	 * @attribute.pieSliceStyle - string, optional -  Applies to chartseries type attribute value pie. Not implemented (limited Chart.js support)
	 * @attribute.xOffset - number, optional -  Applies if show3D="yes". Not implemented (Chart.js doesn't support true 3D)
	 * @attribute.yOffset - number, optional -  Applies if show3D="yes". Not implemented (Chart.js doesn't support true 3D)
	 * @attribute.base64 - boolean, optional -  Render chart inline using a base64 data url. Not implemented (complex feature, not essential)
	 *
	 * @return A BodyResult instance or null for a default result return.
	 */
	function invoke( required context, Struct attributes, any body, Struct executionState ){
		// Initialize storage for chart series data
		executionState.chartSeries = [];

		// Set default attributes
		var chartId = "chart_" & createUUID().replace("-", "", "all");
		var chartWidth = attributes.chartwidth ?: 400;
		var chartHeight = attributes.chartheight ?: 300;
		var title = attributes.title ?: "";
		var backgroundColor = attributes.backgroundcolor ?: "##ffffff";
		var showLegend = attributes.showlegend ?: true;
		var show3d = attributes.show3d ?: false;
		var format = attributes.format ?: "canvas"; // We'll always render as canvas

		// Axis titles
		var xAxisTitle = attributes.xaxistitle ?: "";
		var yAxisTitle = attributes.yaxistitle ?: "";

		// Grid lines
		var showXGridlines = attributes.showxgridlines ?: false;
		var showYGridlines = attributes.showygridlines ?: true;

		// Series placement
		var seriesPlacement = attributes.seriesplacement ?: "default";

		// Font attributes - newly implemented
		var fontBold = attributes.fontbold ?: false;
		var fontItalic = attributes.fontitalic ?: false;
		var fontSize = attributes.fontsize ?: 12;

		// Color attributes - newly implemented
		var dataBackgroundColor = attributes.databackgroundcolor ?: "";
		var foregroundColor = attributes.foregroundcolor ?: "##333333";

		// Display control attributes - newly implemented
		var showBorder = attributes.showborder ?: false;
		var showMarkers = attributes.showmarkers ?: true;
		var showXLabel = attributes.showxlabel ?: true;
		var showTooltip = attributes.showtooltip ?: true;

		// Axis formatting - newly implemented
		var labelFormat = attributes.labelformat ?: "";
		var categoryLabelPositions = attributes.categorylabelpositions ?: "horizontal";

		// Scale control - newly implemented
		var scaleFrom = attributes.scalefrom ?: "";
		var scaleTo = attributes.scaleto ?: "";
		var markerSize = attributes.markersize ?: 4;

		// Data sorting - newly implemented
		var sortXAxis = attributes.sortxaxis ?: false;

		// Click URL - newly implemented
		var url = attributes.url ?: "";

		// Process the body to collect chart series data
		var buffer = newBuffer();
		var bodyResult = processBody( context, body, buffer );

		// If there was a return statement inside our body, we early exit now
		if ( bodyResult.isEarlyExit() ) {
			return bodyResult;
		}

		// Ensure Chart.js is loaded
		ensureChartJSLoaded( context );

		// Build the chart configuration
		var chartConfig = buildChartConfig(
			executionState.chartSeries,
			title,
			backgroundColor,
			showLegend,
			show3d,
			xAxisTitle,
			yAxisTitle,
			showXGridlines,
			showYGridlines,
			seriesPlacement,
			fontBold,
			fontItalic,
			fontSize,
			dataBackgroundColor,
			foregroundColor,
			showBorder,
			showMarkers,
			showXLabel,
			showTooltip,
			labelFormat,
			categoryLabelPositions,
			scaleFrom,
			scaleTo,
			markerSize,
			sortXAxis,
			url
		);

		// Render the chart HTML and JavaScript
		renderChart( context, chartId, chartWidth, chartHeight, chartConfig );
	}

	/**
	 * Ensures Chart.js library is loaded in the page head
	 */
	private function ensureChartJSLoaded( required context ) {
		// Use the BoxLang web htmlHead() BIF to include Chart.js
		if ( !context.hasAttachment( "chartJSLoaded" ) ) {
			context.putAttachment( "chartJSLoaded", true );

			// Include Chart.js from our lib folder via Asset.bx
			var scriptTag = '<script src="/bxmodules/bxcharts/public/Asset.bx?method=deliver&target=chart.min.js"></script>';

			// Call the htmlHead BIF to add the script tag
			htmlHead( scriptTag );
		}
	}

	/**
	 * Normalizes color values to proper hex format for Chart.js
	 */
	private function normalizeColor( required color ) {
		if ( len( color ) == 0 ) {
			return "";
		}

		var cleanColor = trim( color );

		// Handle BoxLang #### prefix for hex colors
		if ( left( cleanColor, 2 ) == "####" ) {
			return "##" & right( cleanColor, len( cleanColor ) - 2 );
		} else if ( left( cleanColor, 2 ) == "##" ) {
			return cleanColor;
		} else if ( left( cleanColor, 1 ) == "##" ) {
			return cleanColor;
		} else if ( listFindNoCase( "red,blue,green,yellow,orange,purple,pink,brown,gray,grey,black,white,cyan,magenta", cleanColor ) ) {
			return cleanColor;
		} else {
			// Assume it's a hex value without prefix
			return "##" & cleanColor;
		}
	}

	/**
	 * Builds Chart.js configuration from collected series data
	 */
	private function buildChartConfig(
		required array chartSeries,
		title,
		backgroundColor,
		showLegend,
		show3d,
		xAxisTitle,
		yAxisTitle,
		showXGridlines,
		showYGridlines,
		seriesPlacement,
		fontBold,
		fontItalic,
		fontSize,
		dataBackgroundColor,
		foregroundColor,
		showBorder,
		showMarkers,
		showXLabel,
		showTooltip,
		labelFormat,
		categoryLabelPositions,
		scaleFrom,
		scaleTo,
		markerSize,
		sortXAxis,
		url
	) {
		// Normalize colors
		var normalizedForegroundColor = normalizeColor( foregroundColor );
		var normalizedDataBackgroundColor = normalizeColor( dataBackgroundColor );

		// Build font configuration
		var fontStyle = "";
		if ( fontBold && fontItalic ) {
			fontStyle = "bold italic";
		} else if ( fontBold ) {
			fontStyle = "bold";
		} else if ( fontItalic ) {
			fontStyle = "italic";
		} else {
			fontStyle = "normal";
		}

		var config = {
			"type": "pie", // Default to pie, will be overridden by series
			"data": {
				"labels": [],
				"datasets": []
			},
			"options": {
				"responsive": true,
				"plugins": {
					"title": {
						"display": len( title ) > 0,
						"text": title,
						"font": {
							"size": fontSize,
							"style": fontStyle
						},
						"color": normalizedForegroundColor
					},
					"legend": {
						"display": showLegend,
						"labels": {
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						}
					},
					"tooltip": {
						"enabled": showTooltip
					}
				},
				"scales": {
					"x": {
						"display": showXLabel,
						"title": {
							"display": len( xAxisTitle ) > 0,
							"text": xAxisTitle,
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						},
						"grid": {
							"display": showXGridlines
						},
						"ticks": {
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						}
					},
					"y": {
						"display": true,
						"title": {
							"display": len( yAxisTitle ) > 0,
							"text": yAxisTitle,
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						},
						"grid": {
							"display": showYGridlines
						},
						"ticks": {
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						}
					}
				}
			}
		};

		// Add scale limits if specified
		if ( len( scaleFrom ) > 0 ) {
			config.options.scales.y.min = val( scaleFrom );
		}
		if ( len( scaleTo ) > 0 ) {
			config.options.scales.y.max = val( scaleTo );
		}

		// Add label formatting if specified
		if ( len( labelFormat ) > 0 ) {
			// We'll handle this in the rendered JavaScript
			config.options.scales.y.labelFormat = labelFormat;
		}

		// Add category label positioning
		if ( categoryLabelPositions != "horizontal" ) {
			var rotation = 0;
			switch ( categoryLabelPositions ) {
				case "up_45":
					rotation = -45;
					break;
				case "up_90":
					rotation = -90;
					break;
				case "down_45":
					rotation = 45;
					break;
				case "down_90":
					rotation = 90;
					break;
				case "vertical":
					rotation = -90;
					break;
			}
			config.options.scales.x.ticks.maxRotation = abs( rotation );
			config.options.scales.x.ticks.minRotation = rotation;
		}

		// Add border configuration
		if ( showBorder ) {
			config.options.elements = config.options.elements ?: {};
			config.options.elements.arc = config.options.elements.arc ?: {};
			config.options.elements.arc.borderWidth = 2;
			config.options.elements.arc.borderColor = normalizedForegroundColor;
		}

		// Add click event handling if URL is specified
		if ( len( url ) > 0 ) {
			// We'll handle this in the rendered JavaScript
			config.options.clickUrl = url;
		}

		// Process each chart series
		var processedSeries = chartSeries;

		// Sort series data if requested
		if ( sortXAxis ) {
			for ( var series in processedSeries ) {
				if ( structKeyExists( series, "chartData" ) ) {
					arraySort( series.chartData, function( a, b ) {
						return compare( a.item, b.item );
					} );
				}
			}
		}

		for ( var series in processedSeries ) {
			config.type = series.type; // Use the series type

			var dataset = {
				"label": series.serieslabel ?: series.type,
				"data": [],
				"backgroundColor": []
			};

			// Process chart data items
			var labels = [];
			var values = [];
			var colors = [];

			// Parse color list if provided
			var colorList = [];
			if ( structKeyExists( series, "colorlist" ) && len( series.colorlist ) ) {
				colorList = listToArray( series.colorlist );
				// Normalize hex colors (handle BoxLang #### prefix)
				for ( var i = 1; i <= arrayLen( colorList ); i++ ) {
					var color = trim( colorList[i] );
					// Handle BoxLang #### prefix for hex colors
					if ( left( color, 2 ) == "####" ) {
						colorList[i] = "##" & right( color, len(color) - 2 );
					} else if ( left( color, 1 ) != "##" && !listFindNoCase( "red,blue,green,yellow,orange,purple,pink,brown,gray,black,white", color ) ) {
						colorList[i] = "##" & color;
					}
				}
			}

			// Default colors if none provided
			if ( arrayLen( colorList ) == 0 ) {
				colorList = [ "##FF6384", "##36A2EB", "##FFCE56", "##4BC0C0", "##9966FF", "##FF9F40" ];
			}

			for ( var dataItem in series.chartData ) {
				arrayAppend( labels, dataItem.item );
				arrayAppend( values, val( dataItem.value ) );

				// Assign colors cyclically
				var colorIndex = ( arrayLen( values ) - 1 ) % arrayLen( colorList ) + 1;
				arrayAppend( colors, colorList[ colorIndex ] );
			}

			config.data.labels = labels;
			dataset.data = values;
			dataset.backgroundColor = colors;

			// Chart type specific settings
			if ( series.type == "bar" || series.type == "horizontalbar" ) {
				if ( series.type == "horizontalbar" ) {
					config.type = "bar";
					config.options.indexAxis = "y"; // Make horizontal
				} else {
					config.type = "bar";
				}
				dataset.borderColor = colors;
				dataset.borderWidth = 1;
			} else if ( series.type == "area" ) {
				config.type = "line";
				dataset.fill = true;
				dataset.borderColor = colors[1] ?: "##FF6384";
				dataset.backgroundColor = colors[1] ?: "##FF6384";
				// Apply marker settings for area charts
				dataset.pointRadius = showMarkers ? markerSize : 0;
				dataset.pointHoverRadius = showMarkers ? markerSize + 2 : 0;
			} else if ( series.type == "line" ) {
				dataset.borderColor = colors[1] ?: "##FF6384";
				dataset.backgroundColor = normalizedDataBackgroundColor ?: "transparent";
				dataset.fill = false;
				// Apply marker settings for line charts
				dataset.pointRadius = showMarkers ? markerSize : 0;
				dataset.pointHoverRadius = showMarkers ? markerSize + 2 : 0;
			} else if ( series.type == "scatter" ) {
				config.type = "scatter";
				dataset.showLine = false;
				dataset.pointBackgroundColor = colors;
				dataset.pointRadius = markerSize;
				dataset.pointHoverRadius = markerSize + 2;
			}

			// Handle series placement for bar charts
			if ( config.type == "bar" && seriesPlacement != "default" ) {
				if ( seriesPlacement == "stacked" ) {
					config.options.scales.x.stacked = true;
					config.options.scales.y.stacked = true;
				}
				// Note: "cluster" is the default behavior for Chart.js
			}

			arrayAppend( config.data.datasets, dataset );
		}

		return config;
	}

	/**
	 * Renders the chart HTML canvas and JavaScript initialization
	 */
	private function renderChart( required context, required chartId, chartWidth, chartHeight, config ) {
		// Handle special JavaScript functions that can't be JSON serialized
		var clickUrl = "";
		var labelFormat = "";

		if ( structKeyExists( config.options, "clickUrl" ) ) {
			clickUrl = config.options.clickUrl;
			structDelete( config.options, "clickUrl" );
		}

		if ( structKeyExists( config.options, "scales" )
			&& structKeyExists( config.options.scales, "y" )
			&& structKeyExists( config.options.scales.y, "labelFormat" ) ) {
			labelFormat = config.options.scales.y.labelFormat;
			structDelete( config.options.scales.y, "labelFormat" );
		}

		var jsExtras = "";

		// Add click event handler if URL is specified
		if ( len( clickUrl ) > 0 ) {
			jsExtras &= "config.options.onClick = function(event, elements) { if(elements.length > 0) { window.open('" & clickUrl & "', '_blank'); } };" & char(10);
		}

		// Add label formatting if specified
		if ( len( labelFormat ) > 0 ) {
			jsExtras &= "config.options.scales.y.ticks.callback = function(value, index, values) { return '" & labelFormat & "'.replace('{value}', value); };" & char(10);
		}

		var html = '<div style="width: #chartWidth#px; height: #chartHeight#px;">
			<canvas id="#chartId#" width="#chartWidth#" height="#chartHeight#"></canvas>
		</div>
		<script>
			(function() {
				var ctx = document.getElementById("#chartId#").getContext("2d");
				var config = #JSONSerialize( config )#;

				#jsExtras#

				new Chart(ctx, config);
			})();
		</script>';

		context.writeToBuffer( html );
	}

}