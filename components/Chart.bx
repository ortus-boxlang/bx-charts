/**
 * BoxLang Chart Component - Renders charts
 * <p>
 * This component creates interactive charts
 * It processes chartSeries and chartData child components to build the chart configuration.
 * <p>
 * Basic Usage:
 * <pre>
 * <bx:chart title="My Chart" chartwidth="400" chartheight="300">
 *   <bx:chartseries type="pie">
 *     <bx:chartdata item="Item 1" value="100">
 *     <bx:chartdata item="Item 2" value="200">
 *   </bx:chartseries>
 * </bx:chart>
 * </pre>
 * <p>
 * <h2>Attributes</h2>
 * <h3>Core Attributes</h3>
 * <ul>
 *   <li><b>title</b> (string, optional) - Chart title displayed at the top. Default: ""</li>
 *   <li><b>chartWidth</b> (number, optional) - Chart width in pixels. Default: 400</li>
 *   <li><b>chartHeight</b> (number, optional) - Chart height in pixels. Default: 300</li>
 *   <li><b>backgroundColor</b> (string, optional) - Background color (hex or named color). Default: "#ffffff"</li>
 *   <li><b>showLegend</b> (boolean, optional) - Display legend for multi-series charts. Default: true</li>
 * </ul>
 * <h3>Responsive Attributes</h3>
 * <ul>
 *   <li><b>responsive</b> (boolean, optional) - Enable responsive resizing. Default: true</li>
 *   <li><b>maintainAspectRatio</b> (boolean, optional) - Maintain width/height ratio. Default: true</li>
 *   <li><b>aspectRatio</b> (number, optional) - Aspect ratio (width/height). Default: 2</li>
 *   <li><b>resizeDelay</b> (number, optional) - Delay before resize (ms). Default: 0</li>
 * </ul>
 * <h3>Styling Attributes</h3>
 * <ul>
 *   <li><b>font</b> (string, optional) - Font family for chart text</li>
 *   <li><b>fontBold</b> (boolean, optional) - Bold text. Default: false</li>
 *   <li><b>fontItalic</b> (boolean, optional) - Italic text. Default: false</li>
 *   <li><b>fontSize</b> (number, optional) - Font size in pixels. Default: 12</li>
 *   <li><b>foregroundColor</b> (string, optional) - Text color. Default: "#333333"</li>
 *   <li><b>dataBackgroundColor</b> (string, optional) - Data area background color</li>
 *   <li><b>borderColor</b> (string, optional) - Border color for chart elements (hex or named color). Applies to: bar, line, area, pie, doughnut, radar, polarArea, bubble. Default: ""</li>
 *   <li><b>borderWidth</b> (number, optional) - Border width in pixels. Applies to: bar, line, area, pie, doughnut, radar, polarArea, bubble. Default: 1 for bar, 2 for pie/doughnut/polarArea/bubble, 3 for line/area/radar</li>
 *   <li><b>borderRadius</b> (number, optional) - Border radius in pixels for rounded corners. Applies to: bar, horizontalbar only. Default: 0</li>
 * </ul>
 * <h3>Axis Configuration</h3>
 * <ul>
 *   <li><b>xAxisTitle</b> (string, optional) - X-axis title. Default: ""</li>
 *   <li><b>yAxisTitle</b> (string, optional) - Y-axis title. Default: ""</li>
 *   <li><b>showXGridlines</b> (boolean, optional) - Show X-axis grid lines. Default: false</li>
 *   <li><b>showYGridlines</b> (boolean, optional) - Show Y-axis grid lines. Default: true</li>
 *   <li><b>showXLabel</b> (boolean, optional) - Display X-axis labels. Default: true</li>
 *   <li><b>scaleFrom</b> (number, optional) - Y-axis minimum value</li>
 *   <li><b>scaleTo</b> (number, optional) - Y-axis maximum value</li>
 *   <li><b>sortXAxis</b> (boolean, optional) - Sort labels alphabetically. Default: false</li>
 * </ul>
 * <h3>Display Options</h3>
 * <ul>
 *   <li><b>showBorder</b> (boolean, optional) - Display chart border. Default: false</li>
 *   <li><b>showMarkers</b> (boolean, optional) - Show data point markers. Default: true</li>
 *   <li><b>showTooltip</b> (boolean, optional) - Enable tooltips. Default: true</li>
 *   <li><b>markerSize</b> (number, optional) - Marker size in pixels. Default: 4</li>
 *   <li><b>show3D</b> (boolean, optional) - 3D appearance (limited support). Default: false</li>
 * </ul>
 * <h3>Advanced Options</h3>
 * <ul>
 *   <li><b>seriesPlacement</b> (string, optional) - Series layout: "default", "cluster", "stacked". Default: "default"</li>
 *   <li><b>labelFormat</b> (string, optional) - Y-axis label format (use {value} placeholder). Default: ""</li>
 *   <li><b>categoryLabelPositions</b> (string, optional) - Label rotation: "horizontal", "up_45", "up_90", "down_45", "down_90", "vertical". Default: "horizontal"</li>
 *   <li><b>url</b> (string, optional) - URL to open when clicking data points. Default: ""</li>
 * </ul>
 */
@BoxComponent( "chart" )
@AllowsBody( true )
@RequiresBody( true )
class{

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * --------------------------------------------------------------------------
	 * Static Properties
	 * --------------------------------------------------------------------------
	 */
	static DEFAULT_COLOR_LIST = [ "##FF6384", "##36A2EB", "##FFCE56", "##4BC0C0", "##9966FF", "##FF9F40" ];

	/**
	 * Renders chart based on provided attributes and body content.
	 *
	 * @param context The context of the execution (IBoxContext)
	 * @param attributes The attributes of the component that were passed in
	 * @param body The body of the component containing chartseries and chartdata
	 * @param executionState The execution state of the component
	 *
	 * Supported attributes
	 *
	 * @attribute.backgroundColor - string, optional -  Color of the area between the data background and the chart border, around labels and around the legend. Hexadecimal value or supported named color. For a hex value, use the form: textColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none.
	 * @attribute.borderColor - string, optional -  Border color for chart elements like bars, lines, and pie slices. Hexadecimal value or supported named color. For a hex value, use the form: borderColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none. Applies to: bar, line, area, pie, doughnut, radar, polarArea, bubble. Default: Uses series colors if not specified.
	 * @attribute.borderWidth - number, optional -  Border width in pixels. Applies to: bar, line, area, pie, doughnut, radar, polarArea, bubble. Default: 1 for bar, 2 for pie/doughnut/polarArea/bubble, 3 for line/area/radar.
	 * @attribute.borderRadius - number, optional -  Border radius in pixels for rounded corners on bars. Applies to: bar, horizontalbar only. Default: 0.
	 * @attribute.chartHeight - number, optional -  Chart height; integer number of pixels
	 * @attribute.chartWidth - number, optional -  Chart width; integer number of pixels
	 * @attribute.responsive - boolean, optional -  Enable responsive behavior. When true, chart resizes with container. Default: true
	 * @attribute.maintainAspectRatio - boolean, optional -  Maintain aspect ratio during resize. Default: true
	 * @attribute.aspectRatio - number, optional -  Aspect ratio (width/height) for chart. Default: 2 for most charts
	 * @attribute.resizeDelay - number, optional -  Delay in milliseconds before resize update. Default: 0
	 * @attribute.font - string, optional -  Font of data in column..
	 * @attribute.show3D - boolean, optional -  Display chart with three-dimensional appearance.
	 * @attribute.showLegend - boolean, optional -  yes: if chart contains more than one data series, display legend
	 * @attribute.showXGridlines - boolean, optional -  yes: display X-axis gridlines
	 * @attribute.source - string, optional -  variable name of the source path, if set the path to the source file is returned and no image tag is written to response stream.
	 * @attribute.showYGridlines - boolean, optional -  yes: display Y-axis gridlines.
	 * @attribute.title - string, optional -  Title of the chart.
	 * @attribute.xAxisTitle - string, optional -  text; X-axis title
	 * @attribute.yAxisTitle - string, optional -  text; Y-axis title
	 * @attribute.dataBackgroundColor - string, optional -  color for control. For a hex value, use the form: textColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none.
	 * @attribute.fontBold - boolean, optional -  Yes: displays grid control text in bold.
	 * @attribute.fontItalic - boolean, optional -  Yes: displays grid control text in italics.
	 * @attribute.fontSize - number, optional -  Size of text in column. Default: 12.
	 * @attribute.foregroundColor - string, optional -  color for control. For a hex value, use the form: textColor = "##xxxxxx", where x = 0-9 or A-F; use two hash signs or none. Default: ##333333.
	 * @attribute.labelFormat - string, optional -  Format for Y-axis labels. Use {value} placeholder for the actual value.
	 * @attribute.categoryLabelPositions - string, optional -  Label position relative to axis: standard, up_45, up_90, down_45, down_90 or horizontal (standard) and vertical (down_90). Default is horizontal.
	 * @attribute.markerSize - number, optional -  Size of data point marker in pixels. Integer. Default: 4.
	 * @attribute.scaleFrom - number, optional -  Y-axis minimum value; integer.
	 * @attribute.scaleTo - number, optional -  Y-axis max value; integer.
	 * @attribute.showBorder - boolean, optional -  Whether to display a border around the chart.
	 * @attribute.showMarkers - boolean, optional -  Applies to chartseries type attribute values line, curve and scatter. yes: display markers at data points. Default: true.
	 * @attribute.showXLabel - boolean, optional -  yes: shows the x-axis labels. Default: true.
	 * @attribute.showTooltip - boolean, optional -  show the tooltip or not. Default: true.
	 * @attribute.sortXAxis - boolean, optional -  Display column labels in alphabetic order along X-axis. Ignored if the xAxisType attribute is scale.
	 * @attribute.url - string, optional -  URL to open if the user clicks item in a data series.
	 *
	 * @attribute.format - string, optional -  File format in which to save graph. Not implemented (web charts only support canvas/HTML)
	 * @attribute.name - string, optional -  Page variable name. Not implemented (not applicable to web charts)
	 * @attribute.pieSliceStyle - string, optional -  Applies to chartseries type attribute value pie. Not implemented
	 * @attribute.xOffset - number, optional -  Applies if show3D="yes".
	 * @attribute.yOffset - number, optional -  Applies if show3D="yes".
	 * @attribute.base64 - boolean, optional -  Render chart inline using a base64 data url. Not implemented (complex feature, not essential)
	 *
	 * @return A BodyResult instance or null for a default result return.
	 */
	function invoke( required context, Struct attributes, any body, Struct executionState ){
		// Initialize storage for chart series data
		executionState.chartSeries = [];

		// Set default attributes
		var chartId = "chart_" & createUUID().replace("-", "", "all");
		var chartWidth = attributes.chartwidth ?: 400;
		var chartHeight = attributes.chartheight ?: 300;
		var title = attributes.title ?: "";
		var backgroundColor = attributes.backgroundcolor ?: "##ffffff";
		var showLegend = attributes.showlegend ?: true;
		var show3d = attributes.show3d ?: false;
		var format = attributes.format ?: "canvas"; // We'll always render as canvas

		// Responsive attributes
		var responsive = attributes.responsive ?: true;
		var maintainAspectRatio = attributes.maintainaspectratio ?: true;
		var aspectRatio = attributes.aspectratio ?: 2;
		var resizeDelay = attributes.resizedelay ?: 0;

		// Axis titles
		var xAxisTitle = attributes.xaxistitle ?: "";
		var yAxisTitle = attributes.yaxistitle ?: "";

		// Grid lines
		var showXGridlines = attributes.showxgridlines ?: false;
		var showYGridlines = attributes.showygridlines ?: true;

		// Series placement
		var seriesPlacement = attributes.seriesplacement ?: "default";

		// Font attributes - newly implemented
		var fontBold = attributes.fontbold ?: false;
		var fontItalic = attributes.fontitalic ?: false;
		var fontSize = attributes.fontsize ?: 12;

		// Color attributes - newly implemented
		var dataBackgroundColor = attributes.databackgroundcolor ?: "";
		var foregroundColor = attributes.foregroundcolor ?: "##333333";
		var borderColor = attributes.bordercolor ?: "";
		var borderWidth = attributes.borderwidth ?: 0; // 0 means use chart type defaults
		var borderRadius = attributes.borderradius ?: 0;

		// Display control attributes - newly implemented
		var showBorder = attributes.showborder ?: false;
		var showMarkers = attributes.showmarkers ?: true;
		var showXLabel = attributes.showxlabel ?: true;
		var showTooltip = attributes.showtooltip ?: true;

		// Axis formatting - newly implemented
		var labelFormat = attributes.labelformat ?: "";
		var categoryLabelPositions = attributes.categorylabelpositions ?: "horizontal";

		// Scale control - newly implemented
		var scaleFrom = attributes.scalefrom ?: "";
		var scaleTo = attributes.scaleto ?: "";
		var markerSize = attributes.markersize ?: 4;

		// Data sorting - newly implemented
		var sortXAxis = attributes.sortxaxis ?: false;

		// Click URL - newly implemented
		var url = attributes.url ?: "";

		// Process the body to collect chart series data
		var buffer = newBuffer();
		var bodyResult = processBody( context, body, buffer );

		// If there was a return statement inside our body, we early exit now
		if ( bodyResult.isEarlyExit() ) {
			return bodyResult;
		}

		// Ensure ChartLib	is loaded
		ensureLibIsLoaded( context );

		// Build the chart configuration
		var chartConfig = buildChartConfig(
			executionState.chartSeries,
			title,
			backgroundColor,
			showLegend,
			show3d,
			xAxisTitle,
			yAxisTitle,
			showXGridlines,
			showYGridlines,
			seriesPlacement,
			fontBold,
			fontItalic,
			fontSize,
			dataBackgroundColor,
			foregroundColor,
			borderColor,
			borderWidth,
			borderRadius,
			showBorder,
			showMarkers,
			showXLabel,
			showTooltip,
			labelFormat,
			categoryLabelPositions,
			scaleFrom,
			scaleTo,
			markerSize,
			sortXAxis,
			url,
			responsive,
			maintainAspectRatio,
			aspectRatio,
			resizeDelay
		);

		// Render the chart HTML and JavaScript
		renderChart( context, chartId, chartWidth, chartHeight, chartConfig, responsive );
	}

	/**
	 * Ensures chart library is loaded in the page head
	 */
	private function ensureLibIsLoaded( required context ) {
		if ( !context.hasAttachment( "chartJSLoaded" ) ) {
			context.putAttachment( "chartJSLoaded", true );

			var scriptTag = '<script src="/bxmodules/bxcharts/public/index.bxm?target=chart.min.js"></script>';

			// Call the htmlHead BIF to add the script tag
			htmlHead( scriptTag );
		}
	}

	/**
	 * Normalizes color values to proper hex format
	 */
	private function normalizeColor( required color ) {
		if ( len( color ) == 0 ) {
			return "";
		}

		var cleanColor = trim( color );

		// Handle BoxLang #### prefix for hex colors
		if ( left( cleanColor, 2 ) == "####" ) {
			return "##" & right( cleanColor, len( cleanColor ) - 2 );
		} else if ( left( cleanColor, 2 ) == "##" ) {
			return cleanColor;
		} else if ( left( cleanColor, 1 ) == "##" ) {
			return cleanColor;
		} else if ( listFindNoCase( "red,blue,green,yellow,orange,purple,pink,brown,gray,grey,black,white,cyan,magenta", cleanColor ) ) {
			return cleanColor;
		} else {
			// Assume it's a hex value without prefix
			return "##" & cleanColor;
		}
	}

	/**
	 * Builds configuration from collected series data
	 */
	private function buildChartConfig(
		required array chartSeries,
		title,
		backgroundColor,
		showLegend,
		show3d,
		xAxisTitle,
		yAxisTitle,
		showXGridlines,
		showYGridlines,
		seriesPlacement,
		fontBold,
		fontItalic,
		fontSize,
		dataBackgroundColor,
		foregroundColor,
		borderColor,
		borderWidth,
		borderRadius,
		showBorder,
		showMarkers,
		showXLabel,
		showTooltip,
		labelFormat,
		categoryLabelPositions,
		scaleFrom,
		scaleTo,
		markerSize,
		sortXAxis,
		url,
		responsive,
		maintainAspectRatio,
		aspectRatio,
		resizeDelay
	) {
		// Normalize colors
		var normalizedForegroundColor = normalizeColor( foregroundColor );
		var normalizedDataBackgroundColor = normalizeColor( dataBackgroundColor );
		var normalizedBorderColor = normalizeColor( borderColor );

		// Build font configuration
		var fontStyle = "";
		if ( fontBold && fontItalic ) {
			fontStyle = "bold italic";
		} else if ( fontBold ) {
			fontStyle = "bold";
		} else if ( fontItalic ) {
			fontStyle = "italic";
		} else {
			fontStyle = "normal";
		}

		var config = {
			"type": "pie", // Default to pie, will be overridden by series
			"data": {
				"labels": [],
				"datasets": []
			},
			"options": {
				"responsive": responsive,
				"maintainAspectRatio": maintainAspectRatio,
				"aspectRatio": aspectRatio,
				"resizeDelay": resizeDelay,
				"plugins": {
					"title": {
						"display": len( title ) > 0,
						"text": title,
						"font": {
							"size": fontSize,
							"style": fontStyle
						},
						"color": normalizedForegroundColor
					},
					"legend": {
						"display": showLegend,
						"labels": {
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						}
					},
					"tooltip": {
						"enabled": showTooltip
					}
				},
				"scales": {
					"x": {
						"display": showXLabel,
						"title": {
							"display": len( xAxisTitle ) > 0,
							"text": xAxisTitle,
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						},
						"grid": {
							"display": showXGridlines
						},
						"ticks": {
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						}
					},
					"y": {
						"display": true,
						"title": {
							"display": len( yAxisTitle ) > 0,
							"text": yAxisTitle,
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						},
						"grid": {
							"display": showYGridlines
						},
						"ticks": {
							"font": {
								"size": fontSize,
								"style": fontStyle
							},
							"color": normalizedForegroundColor
						}
					}
				}
			}
		};

		// Add scale limits if specified
		if ( len( scaleFrom ) > 0 ) {
			config.options.scales.y.min = val( scaleFrom );
		}
		if ( len( scaleTo ) > 0 ) {
			config.options.scales.y.max = val( scaleTo );
		}

		// Add label formatting if specified
		if ( len( labelFormat ) > 0 ) {
			// We'll handle this in the rendered JavaScript
			config.options.scales.y.labelFormat = labelFormat;
		}

		// Add category label positioning
		if ( categoryLabelPositions != "horizontal" ) {
			var rotation = 0;
			switch ( categoryLabelPositions ) {
				case "up_45":
					rotation = -45;
					break;
				case "up_90":
					rotation = -90;
					break;
				case "down_45":
					rotation = 45;
					break;
				case "down_90":
					rotation = 90;
					break;
				case "vertical":
					rotation = -90;
					break;
			}
			config.options.scales.x.ticks.maxRotation = abs( rotation );
			config.options.scales.x.ticks.minRotation = rotation;
		}

		// Add border configuration
		if ( showBorder ) {
			config.options.elements = config.options.elements ?: {};
			config.options.elements.arc = config.options.elements.arc ?: {};
			config.options.elements.arc.borderWidth = 2;
			config.options.elements.arc.borderColor = normalizedForegroundColor;
		}

		// Add click event handling if URL is specified
		if ( len( url ) > 0 ) {
			// We'll handle this in the rendered JavaScript
			config.options.clickUrl = url;
		}

		// Process each chart series
		var processedSeries = chartSeries;

		// Sort series data if requested
		if ( sortXAxis ) {
			for ( var series in processedSeries ) {
				if ( structKeyExists( series, "chartData" ) ) {
					arraySort( series.chartData, function( a, b ) {
						return compare( a.item, b.item );
					} );
				}
			}
		}

		for ( var series in processedSeries ) {
			// Initialize dataset for this series
			var dataset = {
				"label": series.serieslabel ?: series.type,
				"data": [],
				"backgroundColor": []
			};

			// Process chart data items
			var labels = [];
			var values = [];
			var colors = [];

			// Parse color list if provided
			var colorList = [];
			if ( structKeyExists( series, "colorlist" ) && len( series.colorlist ) ) {
				colorList = listToArray( series.colorlist );
				// Normalize hex colors (handle BoxLang #### prefix)
				for ( var i = 1; i <= arrayLen( colorList ); i++ ) {
					var color = trim( colorList[i] );
					// Handle BoxLang #### prefix for hex colors
					if ( left( color, 2 ) == "####" ) {
						colorList[i] = "##" & right( color, len(color) - 2 );
					} else if ( left( color, 1 ) != "##" && !listFindNoCase( "red,blue,green,yellow,orange,purple,pink,brown,gray,black,white", color ) ) {
						colorList[i] = "##" & color;
					}
				}
			}

			// Default colors if none provided
			if ( arrayLen( colorList ) == 0 ) {
				colorList = static.DEFAULT_COLOR_LIST;
			}

			for ( var dataItem in series.chartData ) {
				arrayAppend( labels, dataItem.item );

				// For bubble and scatter charts, handle x, y, r coordinates
				if ( series.type == "bubble" && structKeyExists( dataItem, "x" ) && structKeyExists( dataItem, "y" ) && structKeyExists( dataItem, "r" ) ) {
					arrayAppend( values, { "x": val( dataItem.x ), "y": val( dataItem.y ), "r": val( dataItem.r ) } );
				} else {
					arrayAppend( values, val( dataItem.value ) );
				}

				// Assign colors cyclically
				var colorIndex = ( arrayLen( values ) - 1 ) % arrayLen( colorList ) + 1;
				arrayAppend( colors, colorList[ colorIndex ] );
			}

			config.data.labels = labels;
			dataset.data = values;
			dataset.backgroundColor = colors;

			// Get series-level border attributes (override chart-level)
			var seriesBorderColor = structKeyExists( series, "bordercolor" ) && len( series.bordercolor ) ? normalizeColor( series.bordercolor ) : normalizedBorderColor;
			var seriesBorderWidth = structKeyExists( series, "borderwidth" ) && series.borderwidth > 0 ? series.borderwidth : borderWidth;
			var seriesBorderRadius = structKeyExists( series, "borderradius" ) && series.borderradius > 0 ? series.borderradius : borderRadius;

			// Chart type specific settings
			if ( series.type == "bar" || series.type == "horizontalbar" ) {
				if ( series.type == "horizontalbar" ) {
					config.type = "bar";
					config.options.indexAxis = "y"; // Make horizontal
				} else {
					config.type = "bar";
				}
				// Use series-level borderColor if specified, otherwise use chart-level, otherwise use series colors
				dataset.borderColor = len( seriesBorderColor ) > 0 ? seriesBorderColor : colors;
				// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 1
				dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 1;
				// Use series-level borderRadius if specified (bar charts only)
				if ( seriesBorderRadius > 0 ) {
					dataset.borderRadius = seriesBorderRadius;
				}
			} else if ( series.type == "area" ) {
				config.type = "line";
				dataset.fill = true;
				// Use series-level borderColor if specified, otherwise use chart-level, otherwise use series color
				dataset.borderColor = len( seriesBorderColor ) > 0 ? seriesBorderColor : ( colors[1] ?: "##FF6384" );
				dataset.backgroundColor = colors[1] ?: "##FF6384";
				// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 3
				dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 3;
				// Apply marker settings for area charts
				dataset.pointRadius = showMarkers ? markerSize : 0;
				dataset.pointHoverRadius = showMarkers ? markerSize + 2 : 0;
			} else if ( series.type == "line" ) {
				config.type = "line";
				// Use series-level borderColor if specified, otherwise use chart-level, otherwise use series color
				dataset.borderColor = len( seriesBorderColor ) > 0 ? seriesBorderColor : ( colors[1] ?: "##FF6384" );
				dataset.backgroundColor = normalizedDataBackgroundColor ?: "transparent";
				dataset.fill = false;
				// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 3
				dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 3;
				// Apply marker settings for line charts
				dataset.pointRadius = showMarkers ? markerSize : 0;
				dataset.pointHoverRadius = showMarkers ? markerSize + 2 : 0;
			} else if ( series.type == "scatter" ) {
				config.type = "scatter";
				dataset.showLine = false;
				dataset.pointBackgroundColor = colors;
				dataset.pointRadius = markerSize;
				dataset.pointHoverRadius = markerSize + 2;
			} else if ( series.type == "bubble" ) {
				config.type = "bubble";
				dataset.backgroundColor = colors;
				// Use series-level borderColor if specified, otherwise use chart-level, otherwise use series colors
				dataset.borderColor = len( seriesBorderColor ) > 0 ? seriesBorderColor : colors;
				// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 2
				dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 2;
			} else if ( series.type == "pie" ) {
				config.type = "pie";
				// For pie charts, use series-level borderColor if specified, otherwise chart-level
				if ( len( seriesBorderColor ) > 0 ) {
					dataset.borderColor = seriesBorderColor;
					// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 2
					dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 2;
				}
			} else if ( series.type == "doughnut" ) {
				config.type = "doughnut";
				// For doughnut charts, use series-level borderColor if specified, otherwise chart-level
				if ( len( seriesBorderColor ) > 0 ) {
					dataset.borderColor = seriesBorderColor;
					// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 2
					dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 2;
				}
			} else if ( series.type == "radar" ) {
				config.type = "radar";
				// Use series-level borderColor if specified, otherwise use chart-level, otherwise use series color
				dataset.borderColor = len( seriesBorderColor ) > 0 ? seriesBorderColor : ( colors[1] ?: "##FF6384" );
				// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 3
				dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 3;
			} else if ( series.type == "polararea" ) {
				config.type = "polarArea";
				// For polar area charts, use series-level borderColor if specified, otherwise chart-level
				if ( len( seriesBorderColor ) > 0 ) {
					dataset.borderColor = seriesBorderColor;
					// Use series-level borderWidth if specified, otherwise use chart-level, otherwise default to 2
					dataset.borderWidth = seriesBorderWidth > 0 ? seriesBorderWidth : 2;
				}
			}

			// Handle series placement for bar charts
			if ( config.type == "bar" && seriesPlacement != "default" ) {
				if ( seriesPlacement == "stacked" ) {
					config.options.scales.x.stacked = true;
					config.options.scales.y.stacked = true;
				}
			}

			arrayAppend( config.data.datasets, dataset );
		}

		return config;
	}

	/**
	 * Renders the chart HTML canvas and JavaScript initialization
	 *
	 * @context The context to write output to
	 * @chartId The unique ID for the chart canvas
	 * @chartWidth The width of the chart in pixels
	 * @chartHeight The height of the chart in pixels
	 * @config The chart configuration object
	 * @responsive Whether the chart is responsive
	 */
	private function renderChart( required context, required chartId, chartWidth, chartHeight, config, responsive ) {
		// Handle special JavaScript functions that can't be JSON serialized
		var clickUrl = "";
		var labelFormat = "";

		if ( structKeyExists( config.options, "clickUrl" ) ) {
			clickUrl = config.options.clickUrl;
			structDelete( config.options, "clickUrl" );
		}

		if ( structKeyExists( config.options, "scales" )
			&& structKeyExists( config.options.scales, "y" )
			&& structKeyExists( config.options.scales.y, "labelFormat" ) ) {
			labelFormat = config.options.scales.y.labelFormat;
			structDelete( config.options.scales.y, "labelFormat" );
		}

		var jsExtras = "";

		// Add click event handler if URL is specified
		if ( len( clickUrl ) > 0 ) {
			jsExtras &= "config.options.onClick = function(event, elements) { if(elements.length > 0) { window.open('" & clickUrl & "', '_blank'); } };" & char(10);
		}

		// Add label formatting if specified
		if ( len( labelFormat ) > 0 ) {
			jsExtras &= "config.options.scales.y.ticks.callback = function(value, index, values) { return '" & labelFormat & "'.replace('{value}', value); };" & char(10);
		}

		// Build container div with appropriate styling
		var containerStyle = "";
		if ( responsive ) {
			// For responsive charts, use relative sizing
			containerStyle = "position: relative; width: 100%; max-width: #chartWidth#px;";
			if ( !config.options.maintainAspectRatio ) {
				containerStyle &= " height: #chartHeight#px;";
			}
		} else {
			// For non-responsive charts, use fixed dimensions
			containerStyle = "width: #chartWidth#px; height: #chartHeight#px;";
		}

		var html = '<div style="#containerStyle#">
			<canvas id="#chartId#"></canvas>
		</div>
		<script>
			(function() {
				var ctx = document.getElementById("#chartId#").getContext("2d");
				var config = #JSONSerialize( config )#;

				#jsExtras#

				new Chart(ctx, config);
			})();
		</script>';

		context.writeToBuffer( html );
	}

}