/**
 * BoxLang Chart Component - Renders charts using Chart.js
 * <p>
 * This component creates interactive charts using the Chart.js library.
 * It processes chartSeries and chartData child components to build the chart configuration.
 * <p>
 * Basic Usage:
 * <pre>
 * <bx:chart title="My Chart" chartwidth="400" chartheight="300">
 *   <bx:chartseries type="pie">
 *     <bx:chartdata item="Item 1" value="100">
 *     <bx:chartdata item="Item 2" value="200">
 *   </bx:chartseries>
 * </bx:chart>
 * </pre>
 */
@BoxComponent( "chart" )
@AllowsBody( true )
@RequiresBody( true )
class{

	/**
	 * --------------------------------------------------------------------------
	 * Injections
	 * --------------------------------------------------------------------------
	 */
	property name="moduleRecord";
	property name="boxRuntime";
	property name="functionService";
	property name="componentService";
	property name="interceptorService";
	property name="asyncService";
	property name="schedulerService";
	property name="datasourceService";
	property name="cacheService";
	property name="log";

	/**
	 * Renders a chart using Chart.js
	 *
	 * @param context The context of the execution (IBoxContext)
	 * @param attributes The attributes of the component that were passed in
	 * @param body The body of the component containing chartseries and chartdata
	 * @param executionState The execution state of the component
	 *
	 * @return A BodyResult instance or null for a default result return.
	 */
	function invoke( required context, Struct attributes, any body, Struct executionState ){
		// Initialize storage for chart series data
		executionState.chartSeries = [];

		// Set default attributes
		var chartId = "chart_" & createUUID().replace("-", "", "all");
		var chartWidth = attributes.chartwidth ?: 400;
		var chartHeight = attributes.chartheight ?: 300;
		var title = attributes.title ?: "";
		var backgroundColor = attributes.backgroundcolor ?: "##ffffff";
		var showLegend = attributes.showlegend ?: true;
		var show3d = attributes.show3d ?: false;
		var format = attributes.format ?: "canvas"; // We'll always render as canvas

		// Axis titles
		var xAxisTitle = attributes.xaxistitle ?: "";
		var yAxisTitle = attributes.yaxistitle ?: "";

		// Grid lines
		var showXGridlines = attributes.showxgridlines ?: false;
		var showYGridlines = attributes.showygridlines ?: true;

		// Series placement
		var seriesPlacement = attributes.seriesplacement ?: "default";

		// Process the body to collect chart series data
		var buffer = newBuffer();
		var bodyResult = processBody( context, body, buffer );

		// If there was a return statement inside our body, we early exit now
		if ( bodyResult.isEarlyExit() ) {
			return bodyResult;
		}

		// Ensure Chart.js is loaded
		ensureChartJSLoaded( context );

		// Build the chart configuration
		var chartConfig = buildChartConfig(
			executionState.chartSeries,
			title,
			backgroundColor,
			showLegend,
			show3d,
			xAxisTitle,
			yAxisTitle,
			showXGridlines,
			showYGridlines,
			seriesPlacement
		);

		// Render the chart HTML and JavaScript
		renderChart( context, chartId, chartWidth, chartHeight, chartConfig );
	}

	/**
	 * Ensures Chart.js library is loaded in the page head
	 */
	private function ensureChartJSLoaded( required context ) {
		// Use the BoxLang web htmlHead() BIF to include Chart.js
		if ( !context.hasAttachment( "chartJSLoaded" ) ) {
			context.putAttachment( "chartJSLoaded", true );

			// Include Chart.js from our lib folder via Asset.bx
			var scriptTag = '<script src="/bxmodules/bxcharts/public/Asset.bx?method=deliver&target=chart.min.js"></script>';

			// Call the htmlHead BIF to add the script tag
			htmlHead( scriptTag );
		}
	}

	/**
	 * Builds Chart.js configuration from collected series data
	 */
	private function buildChartConfig( required array chartSeries, title, backgroundColor, showLegend, show3d, xAxisTitle, yAxisTitle, showXGridlines, showYGridlines, seriesPlacement ) {
		var config = {
			"type": "pie", // Default to pie, will be overridden by series
			"data": {
				"labels": [],
				"datasets": []
			},
			"options": {
				"responsive": true,
				"plugins": {
					"title": {
						"display": len( title ) > 0,
						"text": title
					},
					"legend": {
						"display": showLegend
					}
				},
				"scales": {
					"x": {
						"display": true,
						"title": {
							"display": len( xAxisTitle ) > 0,
							"text": xAxisTitle
						},
						"grid": {
							"display": showXGridlines
						}
					},
					"y": {
						"display": true,
						"title": {
							"display": len( yAxisTitle ) > 0,
							"text": yAxisTitle
						},
						"grid": {
							"display": showYGridlines
						}
					}
				}
			}
		};

		// Process each chart series
		for ( var series in chartSeries ) {
			config.type = series.type; // Use the series type

			var dataset = {
				"label": series.serieslabel ?: series.type,
				"data": [],
				"backgroundColor": []
			};

			// Process chart data items
			var labels = [];
			var values = [];
			var colors = [];

			// Parse color list if provided
			var colorList = [];
			if ( structKeyExists( series, "colorlist" ) && len( series.colorlist ) ) {
				colorList = listToArray( series.colorlist );
				// Normalize hex colors (handle BoxLang #### prefix)
				for ( var i = 1; i <= arrayLen( colorList ); i++ ) {
					var color = trim( colorList[i] );
					// Handle BoxLang #### prefix for hex colors
					if ( left( color, 2 ) == "####" ) {
						colorList[i] = "##" & right( color, len(color) - 2 );
					} else if ( left( color, 1 ) != "##" && !listFindNoCase( "red,blue,green,yellow,orange,purple,pink,brown,gray,black,white", color ) ) {
						colorList[i] = "##" & color;
					}
				}
			}

			// Default colors if none provided
			if ( arrayLen( colorList ) == 0 ) {
				colorList = [ "##FF6384", "##36A2EB", "##FFCE56", "##4BC0C0", "##9966FF", "##FF9F40" ];
			}

			for ( var dataItem in series.chartData ) {
				arrayAppend( labels, dataItem.item );
				arrayAppend( values, val( dataItem.value ) );

				// Assign colors cyclically
				var colorIndex = ( arrayLen( values ) - 1 ) % arrayLen( colorList ) + 1;
				arrayAppend( colors, colorList[ colorIndex ] );
			}

			config.data.labels = labels;
			dataset.data = values;
			dataset.backgroundColor = colors;

			// Chart type specific settings
			if ( series.type == "bar" || series.type == "horizontalbar" ) {
				if ( series.type == "horizontalbar" ) {
					config.type = "bar";
					config.options.indexAxis = "y"; // Make horizontal
				} else {
					config.type = "bar";
				}
				dataset.borderColor = colors;
				dataset.borderWidth = 1;
			} else if ( series.type == "area" ) {
				config.type = "line";
				dataset.fill = true;
				dataset.borderColor = colors[1] ?: "##FF6384";
				dataset.backgroundColor = colors[1] ?: "##FF6384";
			} else if ( series.type == "scatter" ) {
				config.type = "scatter";
				dataset.showLine = false;
				dataset.pointBackgroundColor = colors;
			}

			// Handle series placement for bar charts
			if ( config.type == "bar" && seriesPlacement != "default" ) {
				if ( seriesPlacement == "stacked" ) {
					config.options.scales.x.stacked = true;
					config.options.scales.y.stacked = true;
				}
				// Note: "cluster" is the default behavior for Chart.js
			}

			arrayAppend( config.data.datasets, dataset );
		}

		return config;
	}

	/**
	 * Renders the chart HTML canvas and JavaScript initialization
	 */
	private function renderChart( required context, required chartId, chartWidth, chartHeight, config ) {
		var html = '<div style="width: #chartWidth#px; height: #chartHeight#px;">
			<canvas id="#chartId#" width="#chartWidth#" height="#chartHeight#"></canvas>
		</div>
		<script>
			(function() {
				var ctx = document.getElementById("#chartId#").getContext("2d");
				new Chart(ctx, #JSONSerialize( config )#);
			})();
		</script>';

		context.writeToBuffer( html );
	}

}